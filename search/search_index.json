{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Execution Flows","text":"<p>Execution Flows fy tool generates Python class mixins code using a simple declarative description written in fy code.</p> <p>Easily and quickly break down your code into reusable parts - property and methods mixins,  and put them up together into flows - a top-level class for use case implementations.</p> <ul> <li>Introduction</li> <li>Installation</li> <li>Tutorial</li> </ul>"},{"location":"#private-beta","title":"Private Beta","text":"<p>This tool is in the early stages of development, and to maintain a high development velocity, we may occasionally deliver breaking changes without prior announcement.</p> <p>Currently, only a select few companies are using it in production with our direct support.</p> <p>You are welcome to try and test the repository, tool, and code for hobby projects. However, if you plan to use the tool in production systems, please let us know. There may be unannounced breaking changes in upcoming releases, and we want to avoid causing any issues.</p>"},{"location":"getting_started/installation/","title":"Installation and setup","text":""},{"location":"getting_started/installation/#1-install-the-fy-cli-tool","title":"1. Install the fy CLI Tool","text":"<p>Using poetry:</p> <pre><code>poetry add fy-tool-cli\n</code></pre> <p>Using pip:</p> <pre><code>pip install fy-tool-cli\n</code></pre> <p>Then run it with following command</p> <pre><code>fy [--root &lt;path to the source root&gt;] &lt;path to the folder to process&gt;\n</code></pre> <p>It is a good practice to connect the script to a shortcut inside your IDE so you can run it as often as you write some fy code that needs to be processed.</p>"},{"location":"getting_started/project_structure/","title":"Recommended Project Structure","text":"<p>Here's the recommended structure of a project utilizing the fy tool:</p> <pre><code>\u251c\u2500\u2500 &lt;project directory&gt;\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 flows\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 main_flow_fy.py\n\u2502   \u2502   \u251c\u2500\u2500 mixins\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 method\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 greet\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 using_hello_world_fy.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 property\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 greeting\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 abc_fy.py\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 greeting_fy.py\n\u251c\u2500\u2500 fy\n\u2502   \u251c\u2500\u2500 cli\n\u2502   \u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   ...\n\u2502   \u251c\u2500\u2500 fy.sh\n</code></pre>"},{"location":"getting_started/project_structure/#python-package-for-flows","title":"Python Package for Flows","text":"<p>The <code>flows</code> package contains all flow-related files. Each file must end with the suffix <code>_fy.py</code>.</p>"},{"location":"getting_started/project_structure/#python-package-for-mixins","title":"Python Package for Mixins","text":"<p>The <code>mixins</code> package is organized into two sub-packages:</p> <ul> <li> <p>Method Mixins: Contains directories and files related to method mixins. Files in this sub-package must end with <code>_fy.py</code>. For example an implementation of the method <code>greet</code> is located under <code>mixins/method/greet/</code> and is named by its implementation name - <code>using_hello_world_fy.py</code>.</p> </li> <li> <p>Property Mixins: Contains directories and files related to property mixins. Files in this sub-package must also end with <code>_fy.py</code>. For example, <code>abc_fy.py</code> and <code>greeting_fy.py</code> are located under <code>mixins/property/greeting/</code>.</p> </li> </ul> <p>This structure ensures that flow files and mixin files are consistently named and organized, making the project easier to manage and navigate.</p>"},{"location":"getting_started/project_structure/#more-granular-split-for-large-projects","title":"More granular split for large projects","text":"<p>While this is the recommended directory structure, larger projects with hundreds of flows and mixins require a more granular approach. This can involve a horizontal or vertical split.</p> <p>A horizontal split follows the application layers, such as API, business logic, ORM or data access layer, third-party integrations, and similar application layers.</p> <p>A vertical split divides the structure across domain boundaries, such as authentication, authorization, organization, different domain spaces, payment and billing, reporting, and similar domains.</p> <p>For large projects, the most effective approach is to combine both methods: first, apply a horizontal split by application layer, then within each layer, apply vertical splits across domain lines.</p>"},{"location":"introduction/background/","title":"Background","text":"<p>The motivation behind the creation of the Execution Flows fy [pronounced fai] tool stems from the need to deliver large, complex projects with hundreds of different use cases. These are common in Enterprise Software, where you often need to:</p> <ol> <li>Deliver specific customizations for customers.</li> <li>Integrate with various external vendors, automation tools, CRMs, payment systems, data feeds, communication channels, etc.</li> <li>Maintain variations of use cases for different user groups, such as customer support, operations, billing and finance, regulatory compliance, security, and more.</li> </ol> <p>This is particularly important where there is a need for a reusability at the sub-line-of-code level. In such cases, implementing variations of use cases often leads to significant code duplication because the required changes are subtle, affecting almost every line of code.</p> <p>To address this challenge, the Execution Flows approach takes the well-known Object-Oriented Programming (OOP) concept of class mixins and elevates it to a first-class citizen\u2014an entity used to deliver entire functionality. Just as an object is central to OOP and a function is to Functional Programming (FP), a flow is central to the Execution Flows programming paradigm. And flows are exclusively constructed from mixins.</p> <p>Managing your code through mixins allows you to break it down into the smallest possible chunks. These mixins are then assembled into what is called a <code>flow</code> class. The fy tool generates the boilerplate Python code for both the mixin classes and the top-level flow classes, allowing you, the developer, to focus on what truly matters: code structure and application logic.</p>"},{"location":"introduction/benefits/","title":"A couple of non-obvious benefits","text":"<p>A flow class cannot be instantiated if it is missing a property or method implementation from the mixin list. Tools like <code>mypy</code> or <code>PyCharm</code> will report classes that are missing an abstract method or property implementation. The Python interpreter raises an exception if you try to instantiate such a class. These tools also identify which abstract method or property is missing its implementation, making it easy to fix the issue.</p> <p>With this feature you get two benefits:</p> <ol> <li>Issues are detected during static code analysis, which is much better than waiting to execute the code to discover the problem.</li> <li>You do not need to worry if you forgot to include a property or mixin implementation. The tools will let you know.</li> </ol>"},{"location":"introduction/comparisons/","title":"Comparison with traditional programming ways","text":"<p>While this is more code than we would typically need in traditional programming, there is one key difference. To use <code>datetime.utcnow().isoformat()</code> as a <code>greeting</code> value, we need to define a property <code>greeting</code> that utilizes this value.</p> fyPython <pre><code>property greeting: str using utc_now_iso_format:\n</code></pre> mixins/property/greeting/using_utc_now_iso_format_fy.py<pre><code>\"\"\"fy\nproperty greeting: str using utc_now_iso_format:\n\"\"\"\nfrom datetime import datetime\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_UsingUtcNowIsoFormat_PropertyMixin:\n\n    @property\n    def _greeting(self) -&gt; str:\n        # fy:end &lt;&lt;&lt;===\n        return datetime.utcnow().isoformat()\n</code></pre> <p>Then the flow would look like:</p> fyPython <pre><code>flow Greet_UsingUtcNowIsoFormat -&gt; None:\n    property greeting using utc_now_iso_format\n    method greet using greeting\n</code></pre> flows/greet__using_utc_now_iso_format__fy.py<pre><code>\"\"\"fy\nflow Greet_UsingUtcNowIsoFormat -&gt; None:\n    property greeting using utc_now_iso_format\n    method greet using greeting\n\"\"\"\nfrom fy_core.base.flow_base import FlowBase\n\nfrom mixins.method.greet.using_greeting_fy import (\n    Greet_UsinGreeting_MethodMixin,\n)\nfrom mixins.property.greeting.using_utc_now_iso_format_fy import (\n    Greeting_UsingUtcNowIsoFormat_PropertyMixin,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greet_UsingUtcNowIsoFormat_Flow(\n    # Property Mixins\n    Greeting_UsingUtcNowIsoFormat_PropertyMixin,\n    # Method Mixins\n    Greet_UsinGreeting_MethodMixin,\n    # Base\n    FlowBase[None],\n):\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        self._greet()\n</code></pre> <p>We can explicitly see that usage of <code>datetime.utcnow().isoformat()</code> is not an accident or error, but is intentional. </p>"},{"location":"introduction/example/","title":"An Example","text":"<p>Info</p> <p>Python code in the examples is primarily boilerplate code generated by the fy tool. The developer only adds custom logic code at the end.</p>"},{"location":"introduction/example/#flow","title":"Flow","text":"fyPython <pre><code>flow HelloWorld -&gt; None:\n    property greeting using hello_world\n    method greet using greeting\n</code></pre> flows/greet__using_greeting__fy.py<pre><code>\"\"\"fy\nflow HelloWorld -&gt; None:\n    property greeting using hello_world\n    method greet using greeting\n\"\"\"\nfrom fy_core.base.flow_base import FlowBase\n\nfrom mixins.method.greet.using_greeting_fy import (\n    Greet_UsinGreeting_MethodMixin,\n)\nfrom mixins.property.greeting.using_hello_world_fy import (\n    Greeting_UsingHelloWorld_PropertyMixin,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greet_UsingGreeting_Flow(\n    # Property Mixins\n    Greeting_UsingHelloWorld_PropertyMixin,\n    # Method Mixins\n    Greet_UsinGreeting_MethodMixin,\n    # Base\n    FlowBase[None],\n):\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        self._greet()\n</code></pre>"},{"location":"introduction/example/#abstract-property-greeting","title":"Abstract Property greeting","text":"fyPython <pre><code>property greeting: str\n</code></pre> mixins/property/greeting/abc_fy.py<pre><code>\"\"\"fy\nproperty greeting: str\n\"\"\"\nimport abc\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_PropertyMixin_ABC(abc.ABC):\n    @property\n    @abc.abstractmethod\n    def _greeting(self) -&gt; str:\n        raise NotImplementedError()\n        # fy:end &lt;&lt;&lt;===\n</code></pre>"},{"location":"introduction/example/#property-greeting-implementation","title":"Property greeting implementation","text":"fyPython <pre><code>property greeting: str using hello_world:\n</code></pre> mixins/property/greeting/using_hello_world_fy.py<pre><code>\"\"\"fy\nproperty greeting: str using hello_world:\n\"\"\"\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_UsingHelloWorld_PropertyMixin:\n\n    @property\n    def _greeting(self) -&gt; str:\n        # fy:end &lt;&lt;&lt;===\n        return \"Hello, World!\"\n</code></pre>"},{"location":"introduction/example/#method-greet-implementation","title":"Method greet implementation","text":"fyPython <pre><code>method greet -&gt; None using greeting:\n    property greeting\n</code></pre> mixins/method/greet/using_greeting_fy.py<pre><code>\"\"\"fy\nmethod greet -&gt; None using greeting:\n    property greeting\n\"\"\"\nimport abc\n\nfrom mixins.property.greeting.abc_fy import (\n    Greeting_PropertyMixin_ABC,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greet_UsingGreeting_MethodMixin(\n    # Property Mixins\n    Greeting_PropertyMixin_ABC,\n    abc.ABC,\n):\n    def _greet(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(self._greeting)\n</code></pre>"},{"location":"introduction/example/#a-quick-overview","title":"A Quick Overview","text":"<ol> <li>The <code>_fy.py</code> file starts with the docstring <code>\"\"\"fy</code>, where the fy code resides. In this example, we define a flow that includes two mixin implementations: a property <code>greeting</code> that returns the string <code>\"Hello, World!\"</code> and a method <code>greet</code> that utilizes the implementation of the <code>greeting</code> property.</li> <li>The block of python code between comments <code># fy:start ===&gt;&gt;&gt;</code> and <code># fy:end &lt;&lt;&lt;===</code> is generated by the fy tool.</li> <li>The user begins by writing the fy block, then runs the tool to generate the boilerplate code, and finally adds custom logic where necessary.</li> </ol>"},{"location":"introduction/explained/","title":"Execution Flows Explained","text":"<p>The strength of the Execution Flows paradigm comes from two key principles:</p> <ol> <li>Simplicity: The fy implementation revolves around just three core entities: flows, methods, and properties. A flow defines a particular use case by integrating property and method mixins into a single class. Property mixins supply data, while method mixins provide actions.</li> <li>Static referencing: Flows, methods, and properties can only use other flows, methods, or properties that they explicitly reference by their identifier.</li> </ol>"},{"location":"introduction/explained/#static-referencing","title":"Static referencing","text":"<p>Static referencing differs from static typing in that it requires not only the type of the entity to match but also its identifier.</p> <p>In traditional static typing environment values are matched by its type. In the following example a function <code>greet</code> accepts any string.</p> <pre><code>def hello_world() -&gt; str:\n    return \"Hello, World!\"\n\ndef greet(greeting: str) -&gt; None:\n    print(greeting)\n\ngreet(hello_world())\n</code></pre> <p>That means that we could also write something like:</p> <pre><code>greet(datetime.utcnow().isoformat())\n</code></pre> <p>We cannot determine just by looking at the code whether this was an error or intentional.</p> <p>Here\u2019s an example of a fy flow with a related method and property that greets the user and returns no value.</p>"},{"location":"introduction/summary/","title":"Summary","text":"<p>Execution Flows paradigm brings a lot of boilerplate code, that's for sure. But the value it brings to large projects is significant.</p> <p>For example, tools like <code>mypy</code> provide much more value when combined with static referencing. </p> <p>Now imagine a large project with hundreds of flows, properties, and methods. Consider how much more robust the entire codebase becomes due to the static referencing.</p>"},{"location":"tutorial/flow/flow/","title":"Flow","text":""},{"location":"tutorial/flow/flow/#hello-world-example","title":"\"Hello World\" Example","text":"<p>The fy tool enables developers to achieve a high level of code reusability by generating object-oriented Python code  defined by flows and mixins. Below is a step-by-step guide to creating a simple \"Hello World\" Python program using the fy declarative language syntax.</p> fyPython <pre><code>flow HelloWorld -&gt; None:\n</code></pre> flows/hello_world_fy.py<pre><code>\"\"\"fy\nflow HelloWorld -&gt; None:\n\"\"\"\n\nfrom fy_core.base.flow_base import FlowBase\n\n\n# fy:start ===&gt;&gt;&gt;\nclass HelloWorld_Flow(\n    # Base\n    FlowBase[None],\n):\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(\"Hello, World!\")\n</code></pre> <p>Each file containing fy code must end with the <code>_fy.py</code> suffix. The fy tool relies on this suffix to identify the files it needs to process. In large projects, this approach significantly reduces execution time.</p>"},{"location":"tutorial/flow/flow/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>flow HelloWorld -&gt; None:</code> <ul> <li>This line declares a new flow, which is essentially a Python class. The name <code>HelloWorld</code> is the identifier for this flow.</li> </ul> <p>Info</p> <p>All flow names have to be written in PascalCase</p> <ul> <li><code>-&gt; None</code> specifies the return type of the flow, which in this case is <code>None.</code></li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code> is always regenerated.</li> <li>The <code>FlowBase</code> import statement is automatically added once at the top of the file. When the fy tool detects this import in the code, it skips adding it again to avoid disrupting the import order.</li> <li>This generated code includes the class definition, base class inheritance, and the <code>__call__</code> method signature.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the <code>flow</code> declaration within the <code>\"\"\"fy block</code>. After the code is generated by the fy tool, the user can add their custom code, such as <code>print(\"Hello, World!\")</code>, inside the <code>__call__</code> method.</li> </ul> </li> </ol> <p>This approach streamlines the development process by automating boilerplate code generation while allowing the user to focus on specific logic.</p>"},{"location":"tutorial/flow/flow/#how-to-use","title":"How to use","text":"<p>Once the fy tool has generated the Python code, you can execute the flow in your Python environment.</p> <pre><code>flow_instance = HelloWorld_Flow()\nflow_instance()\n</code></pre> <p>If everything was done correctly the expected output should be <code>Hello, World!</code>.</p>"},{"location":"tutorial/method/flow_includes_method/","title":"Using Method in Flow","text":"<p>In this section, you'll learn how to use methods withing the flow. We'll expand the \"Hello World\" example by adding a method to the flow.</p>"},{"location":"tutorial/method/flow_includes_method/#syntax","title":"Syntax","text":"fyPython <pre><code>flow HelloWorld_UsingMethod -&gt; None:\n    method greet using constant\n</code></pre> flows/hello_world_using_method_fy.py<pre><code>\"\"\"fy\nflow HelloWorld_UsingMethod -&gt; None:\n    method greet using constant\n\"\"\"\n\nfrom fy_core.base.flow_base import FlowBase\n\nfrom mixins.methods.greet.using_constant_fy import (\n    Greet_UsingConstant_MethodMixin,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass HelloWorld_UsingMethod_Flow(\n    # Method Mixins\n    Greet_UsingConstant_MethodMixin,\n    # Base\n    FlowBase[None],\n):\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        self._greet()\n</code></pre>"},{"location":"tutorial/method/flow_includes_method/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>flow HelloWorld_UsingMethod -&gt; None:</code><ul> <li>Declares a new flow named <code>HelloWorld_UsingMethod</code>, which represents a Python class. </li> <li><code>-&gt; None</code> specifies that the flow does not return a value.</li> </ul> </li> <li><code>method greet using constant</code><ul> <li>Defines a mixin inclusion in the flow that tells the fy tool that the flow class has to inherit the method mixin class.</li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code> is automatically generated by the fy tool.</li> <li>The generated code includes the class definition <code>HelloWorld_Flow</code>, which incorporates the <code>Greet_UsingConstant_MethodMixin</code> mixin and the <code>FlowBase</code> base class. </li> <li>fy tool adds necessary imports, such as <code>Greet_UsingConstant_MethodMixin</code>, which contains the <code>greet</code> method, and <code>FlowBase</code> for flow base class functionality. It adds imports only when they do not exist.</li> <li>The <code>__call__</code> method calls the <code>_greet</code> method.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the flow declaration within the <code>\"\"\"fy</code> block. After generation, the user can add custom logic, such as <code>self._greet()</code>.</li> </ul> </li> </ol>"},{"location":"tutorial/method/method/","title":"Method &amp; Abstract Method","text":""},{"location":"tutorial/method/method/#what-are-methods","title":"What are Methods?","text":"<p>Execution Flows fy methods define class mixins that can be included in flows to perform actions or calculations. </p> <p>Optionally, we can declare methods as abstract, where they are declared but not implemented. This step is required when one method depends on another method.</p> <p>But we have to provide one or more method implementations so flows can include it.</p>"},{"location":"tutorial/method/method/#abstract-method-implementation","title":"Abstract Method Implementation","text":"<p>An abstract method in fy is a method that is declared but not implemented. Abstract methods are used to ensure that any flow using them includes a specific implementation relevant to that flow. This guarantees that the method is implemented in all flows where it is required.</p>"},{"location":"tutorial/method/method/#example","title":"Example","text":"fyPython <pre><code>method greet(greeting: str) -&gt; None\n</code></pre> mixins/method/greet/abc_fy.py<pre><code>\"\"\"fy\nmethod greet(greeting: str) -&gt; None\n\"\"\"\n\nimport abc\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greet_MethodMixin_ABC(abc.ABC):\n    @abc.abstractmethod\n    def _greet(self, greeting: str) -&gt; None:\n        raise NotImplementedError()\n        # fy:end &lt;&lt;&lt;===\n</code></pre>"},{"location":"tutorial/method/method/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>method greet(greeting: str) -&gt; None:</code><ul> <li>This line declares a new abstract method within the flow, where <code>greet</code> is the method name.</li> </ul> <p>Info</p> <p>All property names have to be written in snake_case</p> <ul> <li><code>greeting: str</code> specifies the method's input parameter, which is a string.</li> <li><code>-&gt; None</code> specifies the return type of the method, which in this case is an <code>None</code>.</li> <li>Using an abstract declaration other methods can specify their dependency to this method.</li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code>.</li> <li>The <code>import abc</code> statement is automatically added once at the top of the file. When the fy tool detects this import in the code, it skips adding it again to avoid disrupting the import order.</li> <li>The generated code includes the creation of an abstract base class (ABC) mixin, <code>Greet_MethodMixin_ABC</code>.</li> <li>The <code>_greet</code> method is defined as an abstract method, meaning any subclass must implement this method.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the method declaration within the <code>\"\"\"fy</code> block. The fy tool then generates the boilerplate abstract method code.</li> </ul> </li> </ol>"},{"location":"tutorial/method/method/#method-implementation","title":"Method Implementation","text":"fyPython <pre><code>method greet(greeting: str) -&gt; None using hello_world:\n</code></pre> mixins/method/greet/using_hello_world_fy.py<pre><code>\"\"\"fy\nmethod greet(greeting: str) -&gt; None using hello_world:\n\"\"\"\n# fy:start ===&gt;&gt;&gt;\nclass Greet_UsingHelloWorld_MethodMixin:\n    def _greet(self, greeting: str) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(\"Hello World!\")\n</code></pre>"},{"location":"tutorial/method/method/#breakdown-of-syntax_1","title":"Breakdown of Syntax","text":"<ol> <li><code>method greet(greeting: str) -&gt; None using hello_world:</code><ul> <li>This line declares a method implementation that can be included within the flow. The method name is <code>greet</code>.</li> <li><code>greeting: str</code> specifies that the method takes a parameter named <code>greeting</code> of type <code>str</code> (string).</li> <li><code>-&gt; None</code> indicates that the method does not return any value.</li> <li><code>using hello_world</code> defines the implementation name that is then referenced by the hosting flow when included in a flow.</li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code> is automatically generated by the fy tool.</li> <li>The generated code includes the class definition <code>Greet_UsingHelloWorld_MethodMixin</code>.</li> <li>The <code>_greet</code> method is declared with a <code>greeting</code> parameter and <code>None</code> as a return type, as specified.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the <code>method</code> declaration within the <code>\"\"\"fy</code> block.</li> <li>After the code is generated by the fy tool, the user can add their custom implementation inside the <code>_greet</code> method, such as <code>print(\"Hello World!\")</code>.</li> </ul> </li> </ol>"},{"location":"tutorial/method/method/#usage-in-execution-flows","title":"Usage in Execution Flows","text":"<p>Both abstract methods and methods in Execution Flows are designed to encapsulate behavior or actions. Abstract methods enforce consistent implementation across flows, while method implementations provide a direct way to execute specific actions when included in a flow.</p>"},{"location":"tutorial/method/methods_using_properties/","title":"Integrating Properties with Methods in Execution Flows","text":"<p>In Execution Flows, properties and methods are core features that work together seamlessly to create modular and maintainable code. Methods can directly utilize properties within their implementations, allowing you to define methods that operate based on predefined properties, thereby enhancing the flexibility and power of your code.</p>"},{"location":"tutorial/method/methods_using_properties/#example","title":"Example","text":"<p>Let's walk through how you can define a method that leverages a property, focusing on the structure and the corresponding Python code generated.</p>"},{"location":"tutorial/method/methods_using_properties/#implementing-a-flow","title":"Implementing a Flow","text":"<p>Consider the following Execution Flows setup, where a <code>greeting</code> property is defined as a constant and a <code>greet</code> method uses this property:</p> fyPython <pre><code>method greet -&gt; None using greeting:\n    property greeting\n</code></pre> mixins/method/greet/using_greeting_fy.py<pre><code>\"\"\"fy\nmethod greet -&gt; None using greeting:\n    property greeting\n\"\"\"\n\nimport abc\n\nfrom mixins.property.greeting.abc_fy import (\n    Greeting_PropertyMixin_ABC,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greet_UsingGreeting_MethodMixin(\n    # Property Mixins\n    Greeting_PropertyMixin_ABC,\n    abc.ABC,\n):\n    def _greet(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(self._greeting)\n</code></pre>"},{"location":"tutorial/method/methods_using_properties/#breakdown","title":"Breakdown","text":"<ol> <li><code>method greet -&gt; None using greeting:</code><ul> <li>Method Declaration: Defines an implementation of a method named <code>greet</code>.</li> <li>Return Type: <code>-&gt; None</code> specifies that the method does not return any value.</li> <li>Implementation Name: <code>using greeting</code> defines the implementation name that is then referenced by the hosting flow when included in a flow. Note that <code>greeting</code> in <code>using greeting</code> is not correlated with <code>greeting</code> in <code>with property greeting</code>. The former can be any arbitrary name and defines the method implementation name. The second is a reference to an existing abstract property in the project.</li> </ul> </li> <li><code>property greeting</code><ul> <li>Property Usage: Specifies that the method will use the <code>greeting</code> property in its implementation.</li> </ul> </li> <li>Code Generation:<ul> <li>Automatic Code Generation: The fy tool generates code between <code># fy:start</code> and <code># fy:end</code> including the class definition and the method declaration. </li> <li>Imports: Includes necessary imports, such as <code>Greeting_PropertyMixin_ABC</code>, which contains the <code>greeting</code> property, and <code>abc.ABC</code> for abstract base class functionality.</li> </ul> </li> <li>Class <code>Greet_UsingGreeting_MethodMixin</code> <ul> <li>Base Class: Inherits from <code>Greeting_PropertyMixin_ABC</code> and <code>abc.ABC</code>. This setup ensures that the class will have access to the <code>greeting</code> property implementation. </li> <li>Method Implementation: The <code>_greet</code> method is defined to print the value of the <code>_greeting</code> property, demonstrating how the method utilizes the property.</li> </ul> </li> </ol>"},{"location":"tutorial/method/methods_using_properties/#summary","title":"Summary","text":"<p>This detailed tutorial illustrates how Execution Flows enables seamless integration of properties with methods. By allowing methods to utilize properties, you can create dynamic, reusable, and modular code. The generated Python code maintains a clean separation of concerns, with properties and methods organized into mixins, ensuring that your code is both complex and maintainable. This approach allows you to build complex logic while keeping your codebase organized and consistent.</p>"},{"location":"tutorial/property/property/","title":"What are properties?","text":"<p>Execution Flows fy properties allow you to define Python <code>@property</code> attributes as class mixins. These properties can either be abstract or implemented returning a constant or computed value.</p>"},{"location":"tutorial/property/property/#abstract-property-implementation","title":"Abstract Property Implementation","text":"<p>An abstract property in fy is a property that is declared but not implemented. Abstract properties are used by methods, and other properties. The abstract property is the way for a method, or other property to request from a encapsulating flow to include the implementation of the abstract property.</p>"},{"location":"tutorial/property/property/#example","title":"Example","text":"fyPython <pre><code>property greeting: str\n</code></pre> mixins/property/greeting/abc_fy.py<pre><code>\"\"\"fy\nproperty greeting: str\n\"\"\"\n\nimport abc\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_PropertyMixin_ABC(abc.ABC):\n    @property\n    @abc.abstractmethod\n    def _greeting(self) -&gt; str:\n        raise NotImplementedError()\n        # fy:end &lt;&lt;&lt;===\n</code></pre>"},{"location":"tutorial/property/property/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>property greeting: str</code><ul> <li>This line declares a new abstract property. The property name is <code>greeting</code>, and its type is <code>str</code> (string).</li> </ul> <p>Info</p> <p>All property names have to be written in snake_case</p> <ul> <li>This declaration enables other properties and methods to specify their dependency to this property.</li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code> is always regenerated.</li> <li>The <code>import abc</code> statement is automatically added once at the top of the file. When the fy tool detects this import in the code, it skips adding it again to avoid disrupting the import order.</li> <li>The generated code includes the class definition <code>Greeting_PropertyMixin_ABC</code>.</li> <li>The <code>_greeting</code> property is defined as an abstract property, requiring property implementations to implement this property, and encapsulating flows to include the implementation.</li> <li>This declaration enables other methods and properties to specify their dependency to an implementation of this property.</li> </ul> </li> <li>User Input:<ul> <li>User does not need to write any code.</li> <li>User has to provide a property implementations that are required by flows.</li> </ul> </li> </ol>"},{"location":"tutorial/property/property/#property-implementation","title":"Property Implementation","text":""},{"location":"tutorial/property/property/#example_1","title":"Example","text":"fyPython <pre><code>property greeting: str using hello_world:\n</code></pre> mixins/property/greeting/using_hello_world_fy.py<pre><code>\"\"\"fy\nproperty greeting: str using hello_world:\n\"\"\"\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_UsingHelloWorld_PropertyMixin:\n\n    @cached_property\n    def _greeting(self) -&gt; str:\n        # fy:end &lt;&lt;&lt;===\n        return \"Hello, World!\"\n</code></pre>"},{"location":"tutorial/property/property/#breakdown-of-syntax_1","title":"Breakdown of Syntax","text":"<ol> <li><code>property greeting: str using hello_world:</code><ul> <li>This line declares a new property implementation. The property name is <code>greeting</code>, and its type is <code>str</code> (string).</li> <li><code>using hello_world</code> defines a property implementation name used by the flow when they want to include this specific implementation. </li> </ul> </li> <li>Code Generation:<ul> <li>Everything between <code># fy:start</code> and <code># fy:end</code> is automatically generated by the fy tool.</li> <li>The generated code includes the class definition <code>Greeting_UsingHelloWorld_PropertyMixin</code> and the <code>@property</code> method declaration.</li> </ul> </li> <li>User Input:<ul> <li>Write the <code>property</code> declaration within the <code>\"\"\"fy</code> block. </li> <li>Run the fy tool to generate the boilerplate code.</li> <li>Write the code that implements the property - <code>return \"Hello, World!\"</code>.</li> </ul> </li> </ol>"},{"location":"tutorial/property/property/#properties-are-cached","title":"Properties are Cached","text":"<p>All properties in Execution Flows are \"cached,\" meaning they are computed or initialized only once. Subsequent invocations of the property return the initially stored value. Internally, the fy tool uses the <code>@cached_property</code> decorator when generating code for properties. You can learn more about how <code>@cached_property</code> works from the Python documentation.</p>"},{"location":"tutorial/property/property/#properties-are-lazy","title":"Properties are Lazy","text":"<p>All properties in Execution Flows are \"lazy,\" meaning they are computed or initialized only when first accessed. This comes from the nature of how Execution Flows are constructed - using property and method mixins. Unless someone calls a property or method, it does not get executed.</p>"},{"location":"tutorial/property/property/#usage-in-execution-flows","title":"Usage in Execution Flows","text":"<p>Both abstract properties and properties in Execution Flows are designed to encapsulate data or computations, making managing and accessing the information within your flows easier. Abstract properties enforce consistent implementation across flows, while properties provide a direct way to return constant or computed values.</p>"},{"location":"tutorial/property/property_in_flow/","title":"Property Included in a Flow","text":"<p>In the fy syntax, a property is a class mixin that defines a method annotated with <code>@property</code> Python annotation to provide data to the encapsulating flow. Properties can be defined in various ways, depending on how the data is intended to be used or modified. For instance, a property might fetch data from a database or a third-party API, or it could compute data using other properties included in the flow.</p>"},{"location":"tutorial/property/property_in_flow/#syntax","title":"Syntax","text":"fyPython <pre><code>flow HelloWorld_UsingGreeting -&gt; None:\n    property greeting using hello_world\n</code></pre> mixins/property/greeting/using_hello_world_fy.py<pre><code>\"\"\"fy\nflow HelloWorld_UsingGreeting -&gt; None:\n    property greeting using hello_world\n\"\"\"\n\nfrom fy_core.base.flow_base import FlowBase\n\nfrom mixins.property.greeting.using_hello_world_fy import (\n    Greeting_UsingHelloWorld_PropertyMixin,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass HelloWorld_UsingGreeting_Flow(\n    # Property Mixins\n    Greeting_UsingHelloWorld_PropertyMixin,\n    # Base\n    FlowBase[None],\n):\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(self._greeting)\n</code></pre>"},{"location":"tutorial/property/property_in_flow/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>flow HelloWorld_UsingGreeting -&gt; None:</code><ul> <li>Declares a new flow named <code>HelloWorld_UsingGreeting</code>, which is implemented as a Python class that uses property as a mixin.</li> <li><code>-&gt; None</code> specifies the return type of the flow, which in this case is <code>None</code>.</li> </ul> </li> <li><code>property greeting using hello_world</code><ul> <li>Declares a property named <code>greeting</code> with a constant value or predefined behavior.</li> </ul> </li> <li>Code Generation:<ul> <li>The fy tool generates code between <code># fy:start</code> and <code># fy:end</code> including the class definition and the method declaration. </li> <li>The generated code includes the class definition <code>HelloWorld_UsingGreeting_Flow</code>, which incorporates the <code>Greeting_UsingHelloWorld_PropertyMixin</code> mixin and the <code>FlowBase</code> base class. </li> <li>The <code>Greeting_UsingHelloWorld_PropertyMixin</code> import statement is automatically added once in the file. When the fy tool detects this import in the code, it skips adding it again to avoid disrupting the import order.</li> <li>The declaration of <code>__call__(self) -&gt; None:</code> method.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the <code>flow</code> declaration within the <code>\"\"\"fy</code> block.</li> <li>After boilerplate code generation, the user can add custom functionality, such as <code>print(self._greeting)</code>.</li> </ul> </li> </ol>"},{"location":"tutorial/property/property_in_flow/#summary","title":"Summary","text":"<p>In fy, defining a property in a flow allows you to encapsulate data as an attribute that is used by other property and method mixins included in a flow. A flow can include property implementation that fits its needs, like fetching data from the database or providing a constant value. This makes it easy to manage state and logic in a modular and intuitive way.</p>"},{"location":"tutorial/property/property_with_property/","title":"Property requires another Property","text":"<p>In this code, the fy code is used to define a property that requires another property in order to deliver its functionality. The property <code>greeting</code> uses another property, <code>french_greeting</code>, to provide its value. This approach allows for modular and reusable property definitions. Here\u2019s how each part of the code is defined and how it works:</p>"},{"location":"tutorial/property/property_with_property/#syntax","title":"Syntax","text":"fyPython <pre><code>property greeting: str using french_greeting:\n    property french_greeting\n</code></pre> mixins/property/greeting/using_french_greeting_fy.py<pre><code>\"\"\"fy\nproperty greeting: str using french_greeting:\n    property french_greeting\n\"\"\"\n\nimport abc\n\nfrom mixins.property.french_greeting.abc_fy import (\n    FrenchGreeting_PropertyMixin_ABC,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_UsingFrenchGreeting_PropertyMixin(\n    # Property Mixins\n    FrenchGreeting_PropertyMixin_ABC,\n    abc.ABC,\n):\n    @cached_property\n    def _greeting(self) -&gt; str:\n        # fy:end &lt;&lt;&lt;===\n        return self._french_greeting\n</code></pre> <p>What we have accomplished here is that any method or property that requires property greeting is decoupled from <code>french_greeting</code> property. They do not need to know anything about <code>french_greeting</code> in order to deliver their own functionality that uses property greeting.</p>"},{"location":"tutorial/property/property_with_property/#breakdown-of-syntax","title":"Breakdown of Syntax","text":"<ol> <li><code>property greeting: str using french_greeting:</code><ul> <li>Property Declaration: Defines a property named <code>greeting</code> with a type of <code>str</code> (string). </li> <li>Implementation Name: <code>using french_greeting</code> declares the name of the specific property implementation that is then referenced by the encapsulating flow when included in a flow.</li> </ul> </li> <li><code>property french_greeting</code> <ul> <li>Property Integration: Indicates that the <code>greeting</code> property depends on the <code>french_greeting</code> property. This means the value or behavior of <code>greeting</code> is derived from <code>french_greeting</code>. </li> </ul> </li> <li>Code Generation:<ul> <li>Automatic Code Generation: The fy tool generates the code between <code># fy:start</code> and <code># fy:end</code>. This includes the class definition and the <code>@property</code> method annotation and declaration. </li> <li>Base classes: <code>FrenchGreeting_PropertyMixin_ABC</code> base class ensures the <code>french_greeting</code> property is available. <code>abc.ABC</code> is required because <code>FrenchGreeting_PropertyMixin_ABC</code> is an abstract class.</li> </ul> </li> <li>User Input:<ul> <li>The only code the user needs to write is the <code>property</code> definition within the <code>\"\"\"fy</code> block.</li> <li>After boilerplate code generation, the user can add custom functionality, such as <code>return self._french_greeting</code> to the property method body.</li> </ul> </li> </ol>"},{"location":"tutorial/property/setters/","title":"Property Setters","text":"<p>When using the Execution Flows fy tool, writing a property setter manually involves defining a property and then adding a <code>@&lt;property_name&gt;.setter</code> method to manage how the property value is assigned. Alternatively, the fy tool simplifies this process by generating the necessary boilerplate code. You can declare an abstract property and include <code>property &lt;property_name&gt; using setter</code> in the flow mixins, allowing the tool to automatically handle the setter implementation. This approach streamlines property management in your code.</p>"},{"location":"tutorial/property/setters/#automatically-generated-setter-implementation","title":"Automatically Generated Setter Implementation","text":"<p>When a flow declares a setter, the fy tool checks if a setter implementation for the defined property exists. If it does not find an implementation, it generates one. Additionally, the fy tool generates an <code>__init__</code> method for the encapsulating flow to initialize the setters.</p> <p>Below is an example of the generated code for a setter for the <code>property greeting: str</code>.</p>"},{"location":"tutorial/property/setters/#example","title":"Example","text":"<p>Abstract property definition:</p> fyPython <pre><code>property greeting: str\n</code></pre> mixins/property/greeting/abc_fy.py<pre><code>\"\"\"fy\nproperty greeting: str\n\"\"\"\nimport abc\n\n\n# fy:start ===&gt;&gt;&gt;\nclass Greeting_PropertyMixin_ABC(abc.ABC):\n    @property\n    @abc.abstractmethod\n    def _greeting(self) -&gt; str:\n        raise NotImplementedError()\n</code></pre> <p>Property setter defined as a flow mixin:</p> fyPython <pre><code>flow HelloWorld_UsingGreeting -&gt; None:\n    property greeting using setter\n</code></pre> flows/hello_world_using_setter_fy.py<pre><code>\"\"\"fy\nflow HelloWorld_UsingGreeting -&gt; None:\n    property greeting using setter\n\"\"\"\nfrom typing import Any\n\nfrom fy_core.base.flow_base import FlowBase\n\nfrom mixins.property.greeting.using_setter_fy import (\n    Greeting_UsingSetter_PropertyMixin,\n)\n\n\n# fy:start ===&gt;&gt;&gt;\nclass HelloWorld_UsingSetter_Flow(\n    # Property Mixins\n    Greeting_UsingSetter_PropertyMixin,\n    # Base\n    FlowBase[None],\n):\n    def __init__(\n        self,\n        *args: Any,\n        greeting: str,\n        **kwargs: Any,\n    ) -&gt; None:\n        self._greeting = greeting\n        super().__init__(*args, **kwargs)\n\n    def __call__(self) -&gt; None:\n        # fy:end &lt;&lt;&lt;===\n        print(self._greeting)\n</code></pre> <p>A Python file generated by the fy tool</p> Python mixins/property/greeting/using_setter.py<pre><code># fy:start ===&gt;&gt;&gt;\nclass Greeting_UsingSetter_PropertyMixin:\n    @property\n    def _greeting(self) -&gt; str:\n        raise NotImplementedError()\n\n    @_greeting.setter\n    def _greeting(self, value: str) -&gt; None:\n        raise NotImplementedError()\n        # fy:end &lt;&lt;&lt;===\n</code></pre>"}]}