# Introduction to Execution Flows

## Background

The motivation behind the creation of the _Execution Flows_ ___fy___ [pronounced _fai_] tool stems from the need to deliver large, complex projects with hundreds of different use cases. These are common in Enterprise Software, where you often need to:

1. Deliver specific customizations for customers.
2. Integrate with various external vendors, automation tools, CRMs, payment systems, data feeds, communication channels, etc.
3. Maintain variations of use cases for different user groups, such as customer support, operations, billing and finance, regulatory compliance, security, and more.

This is particularly important where there is a need for a reusability at the sub-line-of-code level. In such cases, implementing variations of use cases often leads to significant code duplication because the required changes are subtle, affecting almost every line of code.

To address this challenge, the _Execution Flows_ approach takes the well-known Object-Oriented Programming (OOP) concept of [class mixins](https://en.wikipedia.org/wiki/Mixin) and elevates it to a first-class citizen—an entity used to deliver entire functionality. Just as an object is central to OOP and a function is to Functional Programming (FP), a flow is central to the _Execution Flows_ programming paradigm. And flows are exclusively constructed from mixins.

Managing your code through mixins allows you to break it down into the smallest possible chunks. These mixins are then assembled into what is called a `flow` class. The ___fy___ tool generates the boilerplate Python code for both the mixin classes and the top-level flow classes, allowing you, the developer, to focus on what truly matters: code structure and application logic.

## _Execution Flows_ Explained

The strength of the _Execution Flows_ paradigm comes from two key principles:

1. **Simplicity**: The ___fy___ implementation revolves around just three core entities: _flows_, _methods_, and _properties_. A _flow_ defines a particular use case by integrating _property_ and _method_ mixins into a single class. _Property_ mixins supply data, while _method_ mixins provide actions.
2. **Static referencing**: Flows, methods, and properties can only use other flows, methods, or properties that they explicitly reference by their identifier.

### Static referencing

_Static referencing_ differs from _static typing_ in that it requires not only the type of the entity to match but also its identifier.

In traditional _static typing_ environment values are matched by its type. In the following example a function `greet` accepts any string.

```python
def hello_world() -> str:
    return "Hello, World!"

def greet(greeting: str) -> None:
    print(greeting)

greet(hello_world())
```

That means that we could also write something like:

```python
greet(datetime.utcnow().isoformat())
```

We cannot determine just by looking at the code whether this was an error or intentional.

Here’s an example of a ___fy___ flow with a related method and property that greets the user and returns no value.

## An Example

!!! info
 
    Python code in the examples is primarily boilerplate code generated by the ___fy___ tool. The developer only adds custom logic code at the end.

#### Flow

=== "fy"

    ```fy 
    flow HelloWorld -> None:
        property greeting using hello_world
        method greet using greeting
    ```

=== "Python"

    ``` python title="flows/greet__using_greeting__fy.py" linenums="1"
    """fy
    flow HelloWorld -> None:
        property greeting using hello_world
        method greet using greeting
    """
    from base.flow_base import FlowBase
    
    from mixins.method.greet.using_greeting_fy import (
        Greet_UsinGreeting_MethodMixin,
    )
    from mixins.property.greeting.using_hello_world_fy import (
        Greeting_UsingHelloWorld_PropertyMixin,
    )
    
    
    # fy:start ===>>>
    class Greet_UsingGreeting_Flow(
        # Property Mixins
        Greeting_UsingHelloWorld_PropertyMixin,
        # Method Mixins
        Greet_UsinGreeting_MethodMixin,
        # Base
        FlowBase[None],
    ):
        def __call__(self) -> None:
            # fy:end <<<===
            self._greet()
    ```

#### Abstract Property _greeting_

=== "fy"

    ```fy 
    property greeting: str
    ```

=== "Python"

    ``` python title="mixins/property/greeting/abc_fy.py" linenums="1"
    """fy
    property greeting: str
    """
    import abc
    
    
    # fy:start ===>>>
    class Greeting_PropertyMixin_ABC(abc.ABC):
        @property
        @abc.abstractmethod
        def _greeting(self) -> str:
            raise NotImplementedError()
            # fy:end <<<===
    ```

#### Property _greeting_ implementation

=== "fy"

    ```fy 
    property greeting: str using hello_world:
    ```

=== "Python"

    ```py title="mixins/property/greeting/using_hello_world_fy.py" linenums="1"
    """fy
    property greeting: str using hello_world:
    """


    # fy:start ===>>>
    class Greeting_UsingHelloWorld_PropertyMixin:
    
        @property
        def _greeting(self) -> str:
            # fy:end <<<===
            return "Hello, World!"
    ```

#### Method _greet_ implementation

=== "fy"

    ```fy 
    method greet -> None using greeting:
        property greeting
    ```

=== "Python"

    ```py title="mixins/method/greet/using_greeting_fy.py" linenums="1"
    """fy
    method greet -> None using greeting:
        property greeting
    """
    import abc
    
    from mixins.property.greeting.abc_fy import (
        Greeting_PropertyMixin_ABC,
    )
    
    
    # fy:start ===>>>
    class Greet_UsingGreeting_MethodMixin(
        # Property Mixins
        Greeting_PropertyMixin_ABC,
        abc.ABC,
    ):
        def _greet(self) -> None:
            # fy:end <<<===
            print(self._greeting)
    ```

### A Quick Overview

1. The `_fy.py` file starts with the docstring `"""fy`, where the ___fy___ code resides. In this example, we define a flow that includes two mixin implementations: a property `greeting` that returns the string `"Hello, World!"` and a method `greet` that utilizes the implementation of the `greeting` property.
2. The block of python code between comments `:::py # fy:start ===>>>` and `:::py # fy:end <<<===` is generated by the ___fy___ tool.
3. The user begins by writing the ___fy___ block, then runs the tool to generate the boilerplate code, and finally adds custom logic where necessary.


## Comparison with traditional programming ways

While this is more code than we would typically need in traditional programming, there is one key difference. To use `datetime.utcnow().isoformat()` as a `greeting` value, we need to define a property `greeting` that utilizes this value.

=== "fy"

    ```fy 
    property greeting: str using utc_now_iso_format:
    ```

=== "Python"

    ```py title="mixins/property/greeting/using_utc_now_iso_format_fy.py" linenums="1"
    """fy
    property greeting: str using utc_now_iso_format:
    """
    from datetime import datetime
    
    
    # fy:start ===>>>
    class Greeting_UsingUtcNowIsoFormat_PropertyMixin:
    
        @property
        def _greeting(self) -> str:
            # fy:end <<<===
            return datetime.utcnow().isoformat()
    ```

Then the flow would look like:

=== "fy"

    ```fy 
    flow Greet_UsingUtcNowIsoFormat -> None:
        property greeting using utc_now_iso_format
        method greet using greeting
    ```

=== "Python"

    ```python title="flows/greet__using_utc_now_iso_format__fy.py" linenums="1"
    """fy
    flow Greet_UsingUtcNowIsoFormat -> None:
        property greeting using utc_now_iso_format
        method greet using greeting
    """
    from base.flow_base import FlowBase
    
    from mixins.method.greet.using_greeting_fy import (
        Greet_UsinGreeting_MethodMixin,
    )
    from mixins.property.greeting.using_utc_now_iso_format_fy import (
        Greeting_UsingUtcNowIsoFormat_PropertyMixin,
    )
    
    
    # fy:start ===>>>
    class Greet_UsingUtcNowIsoFormat_Flow(
        # Property Mixins
        Greeting_UsingUtcNowIsoFormat_PropertyMixin,
        # Method Mixins
        Greet_UsinGreeting_MethodMixin,
        # Base
        FlowBase[None],
    ):
        def __call__(self) -> None:
            # fy:end <<<===
            self._greet()
    ```

We can explicitly see that usage of `datetime.utcnow().isoformat()` is not an accident or error, but is intentional. 

## A couple of non-obvious benefits

A flow class cannot be instantiated if it is missing a property or method implementation from the mixin list. Tools like `mypy` or `PyCharm` will report classes that are missing an abstract method or property implementation. The Python interpreter raises an exception if you try to instantiate such a class. These tools also identify which abstract method or property is missing its implementation, making it easy to fix the issue.

With this feature you get two benefits:

1. Issues are detected during static code analysis, which is much better than waiting to execute the code to discover the problem.
2. You do not need to worry if you forgot to include a property or mixin implementation. The tools will let you know.

## Summary

_Execution Flows_ paradigm brings a lot of boilerplate code, that's for sure. But the value it brings to large projects is significant.

For example, tools like `mypy` provide much more value when combined with _static referencing_. 

Now imagine a large project with hundreds of flows, properties, and methods. Consider how much more robust the entire codebase becomes due to the _static referencing_.
