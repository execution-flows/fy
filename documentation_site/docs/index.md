# Introduction to Execution Flows

## Background

The motivation behind the creation of the _Execution Flows_ `fy` tool stems from the need to deliver large, complex projects with hundreds of different use cases. These are common in Enterprise Software, where you often need to:

1. Deliver customizations for your customers.
2. Integrate with various external vendors, automation tools, CRMs, payment systems, data feeds, communication channels, etc.
3. Support similar use cases for different user groups, such as customer support, operations, billing and finance, regulatory compliance, security, and more.

This is particularly important where there is a need for a reusability at the sub-line-of-code level. In such cases, implementing variations of use cases often leads to significant code duplication because the required changes are subtle, affecting almost every line of code.

To address this challenge, the _Execution Flows_ approach takes the well-known Object-Oriented Programming (OOP) concept of class mixins to the extreme, allowing you to break your code into the smallest possible chunks. These mixins are then assembled into what is called a `flow` class. The `fy` tool generates Python code for both the mixin classes and the top-level flow classes, enabling greater flexibility and maximizing the reduction of code duplication.


## _Execution Flows_ Explained

The strength of the _Execution Flows_ paradigm lies in its simplicity, centering around just three core entities: _flows_, _methods_, and _properties_. _Flow_ defines a particular use-case implementation in its entirety by assembling _property_ and _method_ mixins into a single class. _Property_ mixins supply data, while _method_ mixins provide actions.

### Flows

A _flow_ is a callable entity that takes no arguments and can optionally return a value. For instance, the following function qualifies as a _flow_:

```py
def func() -> None:
    pass
```

Later, when we delve into advanced _Execution Flows_ concepts, we will explore why this definition is significant and how it facilitates various use cases.

In the context of the _fy_ tool, a _flow_ is a callable class that inherits from the `FlowBase` class and implements a `:::py def __call__(self) -> <return type>:` _method_. _Flows_ determine which implementations of _properties_ and _methods_ are used for the specific use case they address.

Here’s an example of a _fy_ flow that greets the user and returns no value:
```fy
flow HelloWorld -> None:
    property greeting using hello_world
    method greet using greeting
```

And the Python code generated by the `fy` tool:

```py linenums="1"
from base.flow_base import FlowBase


# fy:start <<<===
class HelloWorld_Flow(
    # Base
    FlowBase[None]
):
    def __call__(self) -> None:
        # fy:end <<<===
        print("Hello, World!")
```

For details on how to write the `fy` code and generate the corresponding Python code check out the [Tutorial](tutorial/flow/flow/).

### Methods and Properties

In the _Execution Flows_ paradigm, a _method_ is a mixin class that defines a single _method_. This _method_ can take arguments and optionally return a value. Similarly, a _property_ is a mixin class that defines a single _property_, annotated with Python's `:::py @property` decorator.

It’s essential to distinguish between abstract _methods_ or _properties_ and their concrete implementations.

### Abstract Methods and Properties

An _abstract method_ is declared by its name, arguments, and return value:

```py
method greet(greeting: str) -> None:
```
Similarly, the _abstract property_ is defined by its name and type.

```py
property greeting: str
```
These declarations simply announce the existence of a _property_ or _method_ so they can be referenced in the implementations of other _methods_ or _properties_.

### Method and Properties Implementation

To define a _method_ or _property_ implementation, just add a keyword using followed by the implementation name, like so:

```py
method greet(greeting: str) -> None using greeting:
```

Hosting flows utilize a specific implementation of a _property_ or _method_ by referencing its implementation name.

### Methods and properties using other methods and properties

When a _method_ requires other _methods_ or _properties_ to function, it declares these dependencies as mixins. For example, in the previous flow, the `greet` _method_ depends on the `greeting` _property_. The following fy code defines the `greet` _method_ implementation using the `greeting` _property_:

```py
method greet(greeting: str) -> None using greeting:
    with property greeting
```

This code signals to the hosting flow that it must provide an implementation for the `greeting` _property_.

Unlike _methods_, _properties_ can only utilize other _properties_ in their computations.

The ["Tutorial"](/tutorial/flow/flow) chapter provides more details on what development using the _fy_ tool looks like.
