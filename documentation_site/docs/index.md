# Introduction to Execution Flows

## Background

The motivation behind the creation of the _Execution Flows_ ___fy___ tool stems from the need to deliver large, complex projects with hundreds of different use cases. These are common in Enterprise Software, where you often need to:

1. Deliver specific customizations for customers.
2. Integrate with various external vendors, automation tools, CRMs, payment systems, data feeds, communication channels, etc.
3. Support similar use cases for different user groups, such as customer support, operations, billing and finance, regulatory compliance, security, and more.

This is particularly important where there is a need for a reusability at the sub-line-of-code level. In such cases, implementing variations of use cases often leads to significant code duplication because the required changes are subtle, affecting almost every line of code.

To address this challenge, the _Execution Flows_ approach takes the well-known Object-Oriented Programming (OOP) concept of [class mixins](https://en.wikipedia.org/wiki/Mixin) and elevates it to a first-class citizen—an entity that is used to deliver entire functionality. Managing your code through mixins allows you to break it down into the smallest possible chunks. These mixins are then assembled into what is called a `flow` class. The ___fy___ tool generates the boilerplate Python code for both the mixin classes and the top-level flow classes, enabling greater flexibility and maximizing code reuse by reducing duplication.

## _Execution Flows_ Explained

The strength of the _Execution Flows_ paradigm lies in its simplicity, centering around just three core entities: _flows_, _methods_, and _properties_. _Flow_ defines a particular use-case implementation in its entirety by including _property_ and _method_ mixins into a single class. _Property_ mixins supply data, while _method_ mixins provide actions.

### Flows

A _flow_ is a callable entity that takes no arguments and can optionally return a value. For instance, the following function qualifies as a _flow_:

```py
def func() -> None:
    pass
```

Later, when we delve into advanced _Execution Flows_ concepts, we will explore why this definition is significant and how it facilitates various use cases.

In the context of the ___fy___ tool, a _flow_ is a callable class that inherits from the `FlowBase` class and implements a `:::py def __call__(self) -> <return type>:` _method_.
_Flows_ include implementations of _properties_ and _methods_ as class mixins.

Here’s an example of a ___fy___ flow that greets the user and returns no value together with the Python code generated by the ___fy___ tool.

```python title="flows/hello_worlg_using_greeting_fy.py" linenums="1"
"""fy
flow HelloWorld -> None:
    property greeting using hello_world
    method greet using greeting
"""
from base.flow_base import FlowBase

from mixins.method.greet.using_greeting_fy import (
    Greet_UsinGreeting_MethodMixin,
)
from mixins.property.greeting.using_hello_world_fy import (
    Greeting_UsingHelloWorld_PropertyMixin,
)


# fy:start <<<===
class HelloWorld_Flow(
    # Property Mixins
    Greeting_UsingHelloWorld_PropertyMixin,
    # Method Mixins
    Greet_UsinGreeting_MethodMixin,
    # Base
    FlowBase[None]
):
    def __call__(self) -> None:
        # fy:end <<<===
        self._greet()
```

For details on how to write the ___fy___ code and generate the corresponding Python code check out the [Tutorial](./tutorial/flow/flow/).

### Methods and Properties

In the _Execution Flows_ paradigm, a _method_ is a mixin class that defines a single _method_. This _method_ can take arguments and optionally return a value. Similarly, a _property_ is a mixin class that defines a single _property_, annotated with Python's `:::py @property` decorator.

It’s essential to distinguish between abstract _methods_ or _properties_ and their concrete implementations.

### Abstract Methods and Properties

An _abstract method_ is declared by its name, arguments, and return value:

```py
method greet(greeting: str) -> None
```
Similarly, the _abstract property_ is defined by its name and type.

```py
property greeting: str
```
These declarations simply announce the existence of a _property_ or _method_ so they can be referenced in the implementations of other _methods_ or _properties_.

### Method and Properties Implementation

For a hosting flow to include a method or property, it must be implemented. Each method or property can have multiple implementations as needed. This flexibility is where the power of reusability in _Execution Flows_ truly shines. 

To define a _method_ or _property_ implementation, just add a keyword `using` followed by the implementation name, like so:

```py
method greet(greeting: str) -> None using greeting:
```

Hosting flows utilize a specific implementation of a _property_ or _method_ by referencing its implementation name.

### Methods and properties using other methods and properties

When a _method_ requires other _methods_ or _properties_ to implement its functionality, it declares these dependencies as dependent mixins. For example, in the previous flow, the `greet` _method_ depends on the `greeting` _property_. The following ___fy___ code defines the `greet` _method_ implementation using the `greeting` _property_:

```py
method greet(greeting: str) -> None using greeting:
    with property greeting
```

This code signals to the hosting flow that it must include an implementation for the `greeting` _property_.

Unlike _methods_, _properties_ can only utilize other _properties_ in their computations.

The ["Tutorial"](./tutorial/flow/flow) chapter provides more details on what development using the ___fy___ tool looks like.
