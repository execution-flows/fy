# Introduction to Execution Flows

## Background

The motivation behind the creation of the _Execution Flows_ ___fy___ [pronounced _fai_] tool stems from the need to deliver large, complex projects with hundreds of different use cases. These are common in Enterprise Software, where you often need to:

1. Deliver specific customizations for customers.
2. Integrate with various external vendors, automation tools, CRMs, payment systems, data feeds, communication channels, etc.
3. Develop variations of use cases for different user groups, such as customer support, operations, billing and finance, regulatory compliance, security, and more.

This is particularly important where there is a need for a reusability at the sub-line-of-code level. In such cases, implementing variations of use cases often leads to significant code duplication because the required changes are subtle, affecting almost every line of code.

To address this challenge, the _Execution Flows_ approach takes the well-known Object-Oriented Programming (OOP) concept of [class mixins](https://en.wikipedia.org/wiki/Mixin) and elevates it to a first-class citizen—an entity that is used to deliver entire functionality. Managing your code through mixins allows you to break it down into the smallest possible chunks. These mixins are then assembled into what is called a `flow` class. The ___fy___ tool generates the boilerplate Python code for both the mixin classes and the top-level flow classes, enabling greater flexibility and maximizing code reuse.

## _Execution Flows_ Explained

The strength of the _Execution Flows_ paradigm comes from two key principles:

1. **Simplicity**: The ___fy___ implementation revolves around just three core entities: _flows_, _methods_, and _properties_. A _flow_ defines a particular use case by integrating _property_ and _method_ mixins into a single class. _Property_ mixins supply data, while _method_ mixins provide actions.
2. **Static referencing**: Flows, methods, and properties can only use other flows, methods, or properties that they explicitly reference by their identifier.

### Static referencing

_Static referencing_ differs from _static typing_ in that it requires not only the type of the entity to match but also its identifier.

In traditional _static typing_ environment values are matched by its type. In the following example a method `greet` accepts any string.

```python
def hello_world() -> str:
    return "Hello, World!"

def greet(greeting: str) -> None:
    print(greeting)

greet(hello_world())
```

That means that we could also write something like:

```python
greet(datetime.utcnow().isoformat())
```

We cannot determine just by looking at the code whether this was intentional or the desired outcome.

Here’s an example of a ___fy___ flow with a related method and property that greets the user and returns no value.

!!! info
 
    Python code in the examples is primarily boilerplate code generated by the ___fy___ tool. The developer only adds custom logic code at the end.

#### Flow

=== "fy"

    ```fy linenums="1"
    flow HelloWorld -> None:
        property greeting using hello_world
        method greet using greeting
    ```

=== "Python"

    ``` python title="flows/greet__using_greeting__fy.py" linenums="1"
    """fy
    flow HelloWorld -> None:
        property greeting using hello_world
        method greet using greeting
    """
    from base.flow_base import FlowBase
    
    from mixins.method.greet.using_greeting_fy import (
        Greet_UsinGreeting_MethodMixin,
    )
    from mixins.property.greeting.using_hello_world_fy import (
        Greeting_UsingHelloWorld_PropertyMixin,
    )
    
    
    # fy:start <<<===
    class Greet_UsingGreeting_Flow(
        # Property Mixins
        Greeting_UsingHelloWorld_PropertyMixin,
        # Method Mixins
        Greet_UsinGreeting_MethodMixin,
        # Base
        FlowBase[None],
    ):
        def __call__(self) -> None:
            # fy:end <<<===
            self._greet()
    ```

#### Abstract Property _greeting_

=== "fy"

    ```fy linenums="1"
    property greeting: str
    ```

=== "Python"

    ``` python title="mixins/property/greeting/abc_fy.py" linenums="1"
    """fy
    property greeting: str
    """
    import abc
    
    
    # fy:start <<<===
    class With_Greeting_PropertyMixin_ABC(abc.ABC):
        @property
        @abc.abstractmethod
        def _greeting(self) -> str:
            raise NotImplementedError()
            # fy:end <<<===
    ```

#### Property _greeting_ implementation

=== "fy"

    ```fy linenums="1"
    property greeting: str using hello_world:
    ```

=== "Python"

    ```py title="mixins/property/greeting/using_hello_world_fy.py" linenums="1"
    """fy
    property greeting: str using hello_world:
    """


    # fy:start <<<===
    class Greeting_UsingHelloWorld_PropertyMixin:
    
        @property
        def _greeting(self) -> str:
            # fy:end <<<===
            return "Hello, World!"
    ```

#### Method _greet_ implementation

=== "fy"

    ```fy linenums="1"
    method greet -> None using greeting:
        with property greeting
    ```

=== "Python"

    ```py title="mixins/method/greet/using_greeting_fy.py" linenums="1"
    """fy
    method greet -> None using greeting:
        with property greeting
    """
    import abc
    
    from mixins.property.greeting.abc_fy import (
        With_Greeting_PropertyMixin_ABC,
    )
    
    
    # fy:start <<<===
    class Greet_UsingGreeting_MethodMixin(
        # Property Mixins
        With_Greeting_PropertyMixin_ABC,
        abc.ABC,
    ):
        def _greet(self) -> None:
            # fy:end <<<===
            print(self._greeting)
    ```

### A Quick Overview

1. The `_fy.py` file starts with the docstring `"""fy`, where the ___fy___ code resides. In this example, we define a flow that includes two mixin implementations: a property `greeting` that returns the string `"Hello, World!"` and a method `greet` that utilizes the implementation of the `greeting` property.
2. The block of python code between comments `:::py # fy:start <<<===` and `:::py # fy:end <<<===` is generated by the ___fy___ tool.
3. The user begins by writing the ___fy___ block, then runs the tool to generate the boilerplate code, and finally adds custom logic where necessary.


### Comparison with traditional programming ways

While this is more code than we would typically need in traditional programming, there is one key difference. To use `datetime.utcnow().isoformat()` as a `greeting` value, we need to define a property `greeting` that utilizes this value.

=== "fy"

    ```fy linenums="1"
    property greeting: str using utc_now_iso_format:
    ```

=== "Python"

    ```py title="mixins/property/greeting/using_utc_now_iso_format_fy.py" linenums="1"
    """fy
    property greeting: str using utc_now_iso_format:
    """
    from datetime import datetime
    
    
    # fy:start <<<===
    class Greeting_UsingUtcNowIsoFormat_PropertyMixin:
    
        @property
        def _greeting(self) -> str:
            # fy:end <<<===
            return datetime.utcnow().isoformat()
    ```

Then the flow would look like:

=== "fy"

    ```fy linenums="1"
    flow HelloWorld -> None:
        property greeting using utc_now_iso_format
        method greet using greeting
    ```

=== "Python"

    ```python title="flows/greet__using_utc_now_iso_format__fy.py" linenums="1"
    """fy
    flow Greet_UsingUtcNowIsoFormat -> None:
        property greeting using utc_now_iso_format
        method greet using greeting
    """
    from base.flow_base import FlowBase
    
    from mixins.method.greet.using_greeting_fy import (
        Greet_UsinGreeting_MethodMixin,
    )
    from mixins.property.greeting.using_utc_now_iso_format_fy import (
        Greeting_UsingUtcNowIsoFormat_PropertyMixin,
    )
    
    
    # fy:start <<<===
    class Greet_UsingUtcNowIsoFormat_Flow(
        # Property Mixins
        Greeting_UsingUtcNowIsoFormat_PropertyMixin,
        # Method Mixins
        Greet_UsinGreeting_MethodMixin,
        # Base
        FlowBase[None],
    ):
        def __call__(self) -> None:
            # fy:end <<<===
            self._greet()
    ```

We can explicitly see that usage of `datetime.utcnow().isoformat()` is not an accident or error, but is intentional. 

## Summary

_Execution Flows_ paradigm brings a lot of boilerplate code, that's for sure. But the value it brings to large projects is significant.

For example, tools like `mypy` provide much more value when combined with _static referencing_. 

Now imagine a large project with hundreds of flows, properties, and methods. Consider how much more robust the entire codebase becomes due to the _static referencing_.
