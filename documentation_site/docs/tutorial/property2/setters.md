In Execution Flow (fy), setters can be used in conjunction with properties to manage and control how values are assigned. Setters can be abstract or implemented, and the `fy` tool can generate the necessary boilerplate code for you.

## Abstract Setter Implementation
An abstract setter is declared but not implemented. It serves as a placeholder, indicating that a subclass or implementing class must provide the actual setter implementation.
### Example
```py linenums="1"
"""fy
property greeting: str
"""

import abc


# fy:start <<<===
class With_Greeting_PropertyMixin_ABC(abc.ABC):
    @property
    @abc.abstractmethod
    def _greeting(self) -> str:
        raise NotImplementedError()

    @_greeting.setter
    @abc.abstractmethod
    def _greeting(self, value: str) -> None:
        raise NotImplementedError()
        # fy:end <<<===
```
## Implementing Setters
An implemented setter allows you to define how a propertyâ€™s value is set. This can be done by creating a class that provides concrete implementations of the setter methods.
### Example
```py linenums="1" hl_lines="3"
"""fy
flow SetterTest -> None:
    property greeting using setter
"""

from base.execution_flow_base import ExecutionFlowBase
from fy_py_files.test_fy_py_files.flow_using_setters.greeting.using_setter import (
    Greeting_UsingSetter_PropertyMixin,
)


# fy:start <<<===
class SetterTest_Flow(
    # Property Mixins
    Greeting_UsingSetter_PropertyMixin,
    # Base
    ExecutionFlowBase[None]
):
    def __call__(self) -> None:
        # fy:end <<<===
        print(self._greeting)
```

## Property Setter
### Example 
```py
# fy:start <<<===
class Greeting_UsingSetter_PropertyMixin:
    @property
    def _greeting(self) -> str:
        return self.__greeting

    @_greeting.setter
    def _greeting(self, greeting: str) -> None:
        self.__greeting = greeting
        # fy:end <<<===
```

### Breakdown of Syntax
1. `@property` Decorator:
    - **Definition**: Declares the `_greeting` method as a property. This allows the method to be accessed like an attribute, providing controlled access to the underlying data.
2. `@_greeting.setter` Decorator:
    - **Definition**: Declares the `_greeting` method as the setter for the `_greeting` property. This allows the method to set the value of the property.
3. Setter Method:
   - `def _greeting(self, greeting: str) -> None`:
   - **Purpose**: Sets the value of the private attribute `__greeting`. This method is called when a new value is assigned to the property `_greeting`.
4. Code Generation:
    - **Automatic Generation**: The code between `# fy:start` and `# fy:end` is generated by the `fy` tool. This includes the class `Greeting_UsingSetter_PropertyMixin` with property methods. 
    - **User Input**: The user writes the property declaration within the `"""fy` block. The `fy` tool generates the setter methods based on this declaration.
