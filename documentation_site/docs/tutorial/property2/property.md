# What are properties?

`Execution Flow (fy)` properties allow you to define flow attributes that can be accessed in a controlled manner. These properties can either be abstract or implemented returning a constant or computed value.
## Abstract Property Implementation
An abstract property in `fy` is a property that is declared but not implemented. Abstract properties are exclusively used by base flows, methods, and other properties. The abstract property is the way for a base flow, method, or other property to request from a hosting flow to provide the implementation of the abstract property.

### Example
```py title="Abstract Property" linenums="1"
"""fy
property greeting: str
"""

import abc


# fy:start <<<===
class With_Greeting_PropertyMixin_ABC(abc.ABC):
    @property
    @abc.abstractmethod
    def _greeting(self) -> str:
        raise NotImplementedError()
        # fy:end <<<===
```
### Breakdown of Syntax
1. `:::py property greeting: str`
    - This line declares a new property within the flow. The property name is `:::py greeting`, and its type is `:::py str` (string).
    - This declaration specifies that the property will be used in the flow.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end`, including the `:::py import abc` statement at the top, is automatically generated by the `fy` tool.
    - The generated code includes the class definition `:::py With_Greeting_PropertyMixin_ABC`.
    - The `:::py _greeting` property is defined as an abstract property, requiring any subclass to implement this property.
3. User Input:
    - The only code the user needs to write is the `:::py property` declaration within the `:::py """fy` block. The **_fy_** tool generates the abstract property code.
    - The user must implement the `:::py _greeting` property in any subclass of `:::py With_Greeting_PropertyMixin_ABC`.
## Property Implementation
### Example
```py title="Property" linenums="1"
"""fy
property greeting: str using constant:
"""


# fy:start <<<===
class Greeting_UsingConstant_PropertyMixin:

    @property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "Hello, World!"
```

### Breakdown of Syntax
1. `:::py property greeting: str using constant:`
    - This line declares a new property within the flow. The property name is `greeting`, and its type is `str` (string). 
    - `using constant` indicates that the property will have a constant value or predefined behavior in its implementation.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end`, including the `:::py import abc` statement at the top, is automatically generated by the `fy` tool.
    - The generated code includes the class definition With_Greeting_PropertyMixin_ABC.
    - The `:::py _greeting` property is implemented with a constant value, in this case, `:::py "Hello, World!"`.
3. User Input:
    - The only code the user needs to write is the `property` declaration within the `"""fy` block. The `fy` tool generates the property definition with a constant value.
    - The user can customize the constant value or behavior of the `:::py _greeting` property after the code is generated.
## Lazy Properties

Properties can also be defined as "lazy," meaning they are computed or initialized only when first accessed. This can be useful for properties that are expensive to compute and should be cached for efficiency.

### Example

```py linenums="1" hl_lines="2 11"
"""fy
@cached
property greeting: str using greeting:
"""

from functools import cached_property


# fy:start <<<===
class Greeting_UsingGreeting_PropertyMixin:
    @cached_property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "Hello, World!"
```

### Breakdown of Syntax
1. `:::py @cached`
    - **Decorator Usage:** Indicates that the property should be cached, meaning its value is computed once and stored for future access.
2. `:::py property greeting: str using greeting:`
    - Declares a property named `greeting` of type `str` (string), with its value computed from another property or source.
3. Code Generation:
    - The `fy` tool generates the class definition and the `cached_property` implementation for the `_greeting` property.
4. User Input:
    - The user writes the `property` declaration and can use decorators like `:::py @cached_property` to manage lazy evaluation. The `fy` tool handles the rest of the code generation.


## Usage in Execution Flow
Properties in Execution Flow are designed to encapsulate data or computations, simplifying the management and access of information within your flows. Abstract properties ensure consistent implementation across flows, while implemented properties provide direct access to constant or computed values. Lazy properties offer efficient computation and caching for expensive operations.

This structured approach to properties helps maintain clean and manageable code while leveraging the capabilities of the **_fy_** tool for code generation and property management.
