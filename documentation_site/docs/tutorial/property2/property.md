# What are properties?

`Execution Flow (fy)` properties allow you to define flow attributes that can be accessed in a controlled manner. These properties can either be abstract or implemented returning a constant or computed value.
## Abstract Property Implementation
An abstract property in `fy` is a property that is declared but not implemented. Abstract properties are exclusively used by base flows, methods, and other properties. The abstract property is the way for a base flow, method, or other property to request from a hosting flow to provide the implementation of the abstract property.

### Example
```py title="Abstract Property" linenums="1"
"""fy
property greeting: str
"""

import abc


# fy:start <<<===
class With_Greeting_PropertyMixin_ABC(abc.ABC):
    @property
    @abc.abstractmethod
    def _greeting(self) -> str:
        raise NotImplementedError()
        # fy:end <<<===
```
### Breakdown of Syntax
1. `:::py property greeting: str`
    - This line declares a new abstract property. The property name is `:::py greeting`, and its type is `:::py str` (string).
    - This declaration enables other properties and methods to specify their dependency to an implementation of this property.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is always regenerated.
    - `:::py import abc` statement at the top is automatically generated by the `fy` tool only once.
    - The generated code includes the class definition `:::py With_Greeting_PropertyMixin_ABC`.
    - The `:::py _greeting` property is defined as an abstract property, requiring property implementations to implement this property.
    - This declaration enables other methods to specify their dependency to an implementation of this method.
3. User Input:
    - The only code the user needs to write is the `:::py property` declaration within the `:::py """fy` block. The **_fy_** tool generates the abstract property code.
    - The user must implement the `:::py _greeting` property in any subclass of `:::py With_Greeting_PropertyMixin_ABC`.
## Property Implementation
### Example
```py title="Property" linenums="1"
"""fy
property greeting: str using hello_world:
"""


# fy:start <<<===
class Greeting_UsingHelloWorld_PropertyMixin:

    @property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "Hello, World!"
```

### Breakdown of Syntax
1. `:::py property greeting: str using hello_world:`
    - This line declares a new property implementation. The property name is `greeting`, and its type is `str` (string). 
    - `using hello_world` indicates what to expect from the property implementation - a constant string. 
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end`, including the `:::py import abc` statement at the top, is automatically generated by the `fy` tool.
    - The generated code includes the class definition `With_Greeting_PropertyMixin_ABC`.
    - The `:::py _greeting` property is implemented with a constant value, in this case, `:::py "Hello, World!"`.
3. User Input:
    - The user needs to write two parts: first, the `property` declaration within the `"""fy` block. Second, the code that implements the property - return a constant value.
## Cached Properties

Properties can also be defined as "cached," meaning they are computed only once when first accessed. Any subsequent access reads the cached value from the first invocation. This can be useful for properties that are expensive to compute and should be cached for efficiency.

Cached properties should be used whenever the property is _immutable_ - property does not change value during the code execution.

### Example

```py linenums="1" hl_lines="2 11"
"""fy
@cached
property greeting: str using hello_world_list:
"""

from functools import cached_property


# fy:start <<<===
class Greeting_UsingHelloWorldList_PropertyMixin:
    @cached_property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "".join(["H", "e", "l", "l", "o", ",", " ", "W", "o", "r", "l", "d", "!"])
```

### Breakdown of Syntax
1. `:::py @cached`
    - **Decorator Usage:** Indicates that the property should be cached, meaning its value is computed once and stored for future access.
2. `:::py property greeting: str using hello_world_list:`
    - Declares a property named `greeting` of type `str` (string) that is computed using a list of characters.
3. Code Generation:
    - The `fy` tool generates the class definition and the `@cached_property` implementation for the `_greeting` property.
4. User Input:
    - The user writes the `property` declaration and can use decorators like `:::py @cached` to manage cached evaluation. The `fy` tool handles the rest of the code generation.

# Lazy Properties

All properties in _Execution Flows_ are "lazy," meaning they are computed or initialized only when first accessed. This comes from the nature of how _Execution Flows_ are constructed - using property and method mixins. Unless someone calls a property or method, it does not get executed.

## Usage in Execution Flow
Properties in Execution Flow are designed to encapsulate data or computations, simplifying the management and access of information within your flows. Abstract properties ensure consistent implementation across flows, while implemented properties provide direct access to constant or computed values. Cached properties offer efficient computation and caching for expensive operations.

This structured approach to properties helps maintain clean and manageable code while leveraging the capabilities of the **_fy_** tool for code generation and property management.
