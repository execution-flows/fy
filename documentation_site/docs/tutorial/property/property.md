# What are properties?

_Execution Flows_ ___fy___ properties allow you to define Python `@property` attributes as class mixins. These properties can either be abstract or implemented returning a constant or computed value.

## Abstract Property Implementation

An abstract property in ___fy___ is a property that is declared but not implemented. Abstract properties are used by methods, and other properties. The abstract property is the way for a method, or other property to request from a encapsulating flow to include the implementation of the abstract property.

### Example

=== "fy"

    ```fy
    property greeting: str
    ```

=== "Python"
    
    ```py title="mixins/property/greeting/abc_fy.py" linenums="1"
    """fy
    property greeting: str
    """

    import abc
    
    
    # fy:start ===>>>
    class Greeting_PropertyMixin_ABC(abc.ABC):
        @property
        @abc.abstractmethod
        def _greeting(self) -> str:
            raise NotImplementedError()
            # fy:end <<<===
    ```

### Breakdown of Syntax

1. `:::py property greeting: str`
    - This line declares a new abstract property. The property name is `:::py greeting`, and its type is `:::py str` (string).
    !!! info 
        All property names have to be written in [snake_case](https://en.wikipedia.org/wiki/Snake_case)
    - This declaration enables other properties and methods to specify their dependency to this property.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is always regenerated.
    - The `import abc` statement is automatically added once at the top of the file. When the ___fy___ tool detects this import in the code, it skips adding it again to avoid disrupting the import order.
    - The generated code includes the class definition `:::py Greeting_PropertyMixin_ABC`.
    - The `:::py _greeting` property is defined as an abstract property, requiring property implementations to implement this property, and encapsulating flows to include the implementation.
    - This declaration enables other methods and properties to specify their dependency to an implementation of this property.
3. User Input:
    - User does not need to write any code.
    - User has to provide a property implementations that are required by flows.

## Property Implementation

### Example

=== "fy"

    ```fy
    property greeting: str using hello_world:
    ```

=== "Python"

    ```py title="mixins/property/greeting/using_hello_world_fy.py" linenums="1"
    """fy
    property greeting: str using hello_world:
    """
    
    # fy:start ===>>>
    class Greeting_UsingHelloWorld_PropertyMixin:
    
        @cached_property
        def _greeting(self) -> str:
            # fy:end <<<===
            return "Hello, World!"
    ```

### Breakdown of Syntax

1. `:::py property greeting: str using hello_world:`
    - This line declares a new property implementation. The property name is `greeting`, and its type is `str` (string).
    - `using hello_world` defines a property implementation name used by the flow when they want to include this specific implementation. 
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is automatically generated by the ___fy___ tool.
    - The generated code includes the class definition `:::py Greeting_UsingHelloWorld_PropertyMixin` and the `:::py @property` method declaration.
3. User Input:
    - Write the `property` declaration within the `"""fy` block. 
    - Run the ___fy___ tool to generate the boilerplate code.
    - Write the code that implements the property - `:::py return "Hello, World!"`.

## Properties are Cached

All properties in _Execution Flows_ are "cached," meaning they are computed or initialized only once. Subsequent invocations of the property return the initially stored value. Internally, the ___fy___ tool uses the `:::py @cached_property` decorator when generating code for properties. You can learn more about how `:::py @cached_property` works from the [Python documentation](https://docs.python.org/3/library/functools.html#functools.cached_property).

## Properties are Lazy

All properties in _Execution Flows_ are "lazy," meaning they are computed or initialized only when first accessed. This comes from the nature of how _Execution Flows_ are constructed - using property and method mixins. Unless someone calls a property or method, it does not get executed.

## Usage in Execution Flows

Both abstract properties and properties in _Execution Flows_ are designed to encapsulate data or computations, making managing and accessing the information within your flows easier. Abstract properties enforce consistent implementation across flows, while properties provide a direct way to return constant or computed values.

