# What are properties?

_Execution Flows_ ___fy___ properties allow you to define Python `@property` attributes as class mixins. These properties can either be abstract or implemented returning a constant or computed value.

## Abstract Property Implementation

An abstract property in ___fy___ is a property that is declared but not implemented. Abstract properties are used by methods, and other properties. The abstract property is the way for a method, or other property to request from a encapsulating flow to include the implementation of the abstract property.

### Example

```py title="mixins/property/greeting/abc_fy.py" linenums="1"
"""fy
property greeting: str
"""

import abc


# fy:start <<<===
class With_Greeting_PropertyMixin_ABC(abc.ABC):
    @property
    @abc.abstractmethod
    def _greeting(self) -> str:
        raise NotImplementedError()
        # fy:end <<<===
```

### Breakdown of Syntax

1. `:::py property greeting: str`
    - This line declares a new abstract property. The property name is `:::py greeting`, and its type is `:::py str` (string).
    - This declaration enables other properties and methods to specify their dependency to this property.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is always regenerated.
    - The `import abc` statement is automatically added once at the top of the file. When the ___fy___ tool detects this import in the code, it skips adding it again to avoid disrupting the import order.
    - The generated code includes the class definition `:::py With_Greeting_PropertyMixin_ABC`.
    - The `:::py _greeting` property is defined as an abstract property, requiring property implementations to implement this property, and encapsulating flows to include the implementation.
    - This declaration enables other methods and properties to specify their dependency to an implementation of this property.
3. User Input:
    - User does not need to write any code.
    - User has to provide a property implementations that are required by flows.

## Property Implementation

### Example

```py title="mixins/property/greeting/using_hello_world_fy.py" linenums="1"
"""fy
property greeting: str using hello_world:
"""


# fy:start <<<===
class Greeting_UsingHelloWorld_PropertyMixin:

    @property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "Hello, World!"
```

### Breakdown of Syntax

1. `:::py property greeting: str using hello_world:`
    - This line declares a new property implementation. The property name is `greeting`, and its type is `str` (string). 
    - `using hello_world` defines a property implementation name used by the flow when they want to include this specific implementation. 
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is automatically generated by the ___fy___ tool.
    - The generated code includes the class definition `:::py Greeting_UsingHelloWorld_PropertyMixin` and the `:::py @property` method declaration.
3. User Input:
    - Write the `property` declaration within the `"""fy` block. 
    - Run the ___fy___ tool to generate the boilerplate code.
    - Write the code that implements the property - `:::py return "Hello, World!"`.

## Cached Properties

Properties can also be defined as "cached," meaning they are computed only once when first accessed. Any subsequent access reads the cached value from the first invocation. This can be useful for properties that are expensive to compute and should be cached for efficiency.

Cached properties should be used whenever the property is _immutable_ - property does not change value during the code execution.

### Example

```py title="mixins/property/greeting/using_hello_world_list_fy.py" linenums="1" hl_lines="2 11"
"""fy
@cached
property greeting: str using hello_world_list:
"""

from functools import cached_property


# fy:start <<<===
class Greeting_UsingHelloWorldList_PropertyMixin:
    @cached_property
    def _greeting(self) -> str:
        # fy:end <<<===
        return "".join(["H", "e", "l", "l", "o", ",", " ", "W", "o", "r", "l", "d", "!"])
```

### Breakdown of Syntax
1. `:::py @cached`
    - **Decorator Usage:** Indicates that the property should be cached, meaning its value is computed once and stored for future access.
2. `:::py property greeting: str using hello_world_list:`
    - Declares a property named `greeting` of type `str` (string) and implementation name `hello_world_list` that is computed using a list of characters.
3. Code Generation:
    - The ___fy___ tool generates the class definition and the `@cached_property` implementation for the `_greeting` property.
4. User Input:
    - The user writes the `property` declaration and can use decorators like `:::py @cached` to manage cached evaluation. The ___fy___ tool handles the rest of the code generation.

## Properties are Lazy

All properties in _Execution Flows_ are "lazy," meaning they are computed or initialized only when first accessed. This comes from the nature of how _Execution Flows_ are constructed - using property and method mixins. Unless someone calls a property or method, it does not get executed.

## Usage in Execution Flows

Both abstract properties and properties in _Execution Flows_ are designed to encapsulate data or computations, making managing and accessing the information within your flows easier. Abstract properties enforce consistent implementation across flows, while properties provide a direct way to return constant or computed values.

