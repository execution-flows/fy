# Method & Abstract Method

## What are Methods?

_Execution Flows_ ___fy___ methods define class mixins that can be included in flows to perform actions or calculations. 

Optionally, we can declare methods as abstract, where they are declared but not implemented. This step is required when one method depends on another method.

But we have to provide one or more method implementations so flows can include it.

## Abstract Method Implementation

An _abstract method_ in ___fy___ is a method that is declared but not implemented. _Abstract methods_ are used to ensure that any flow using them includes a specific implementation relevant to that flow. This guarantees that the method is implemented in all flows where it is required.

### Example

=== "fy"

    ```fy
    method greet(greeting: str) -> None
    ```

=== "Python"

    ```py title="mixins/method/greet/abc_fy.py" linenums="1"
    """fy
    method greet(greeting: str) -> None
    """

    import abc
    
    
    # fy:start <<<===
    class With_Greet_MethodMixin_ABC(abc.ABC):
        @abc.abstractmethod
        def _greet(self, greeting: str) -> None:
            raise NotImplementedError()
            # fy:end <<<===
    ```

### Breakdown of Syntax

1. `:::py method greet(greeting: str) -> None:`
    - This line declares a new abstract method within the flow, where `greet` is the method name.
    - `:::py greeting: str` specifies the method's input parameter, which is a string.
    - `:::py -> None` specifies the return type of the method, which in this case is an `None`.
    - Using an abstract declaration other methods can specify their dependency to this method.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end`.
    - The `import abc` statement is automatically added once at the top of the file. When the ___fy___ tool detects this import in the code, it skips adding it again to avoid disrupting the import order.
    - The generated code includes the creation of an abstract base class (ABC) mixin, `:::py With_Greet_MethodMixin_ABC`.
    - The `_greet` method is defined as an abstract method, meaning any subclass must implement this method.
3. User Input:
    - The only code the user needs to write is the method declaration within the `"""fy` block. The ___fy___ tool then generates the boilerplate abstract method code.

## Method Implementation

=== "fy"

    ```fy
    method greet(greeting: str) -> None using hello_world:
    ```

=== "Python"

    ```py title="mixins/method/greet/using_hello_world_fy.py" linenums="1"
    """fy
    method greet(greeting: str) -> None using hello_world:
    """
    # fy:start <<<===
    class Greet_UsingHelloWorld_MethodMixin:
        def _greet(self, greeting: str) -> None:
            # fy:end <<<===
            print("Hello World!")
    ```

### Breakdown of Syntax

1. `:::py method greet(greeting: str) -> None using hello_world:`
    - This line declares a method implementation that can be included within the flow. The method name is `:::py greet`.
    - `:::py greeting: str` specifies that the method takes a parameter named `:::py greeting` of type `:::py str` (string).
    - `:::py -> None` indicates that the method does not return any value.
    - `:::py using hello_world` defines the implementation name that is then referenced by the hosting flow when included in a flow.
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is automatically generated by the ___fy___ tool.
    - The generated code includes the class definition `:::py Greet_UsingHelloWorld_MethodMixin`.
    - The `:::py _greet` method is declared with a `:::py greeting` parameter and `:::py None` as a return type, as specified.
3. User Input:
    - The only code the user needs to write is the `:::py method` declaration within the `:::py """fy` block.
    - After the code is generated by the ___fy___ tool, the user can add their custom implementation inside the `:::py _greet` method, such as `:::py print("Hello World!")`.

## Usage in Execution Flows

Both _abstract methods_ and _methods_ in _Execution Flows_ are designed to encapsulate behavior or actions. _Abstract methods_ enforce consistent implementation across flows, while method implementations provide a direct way to execute specific actions when included in a flow.
