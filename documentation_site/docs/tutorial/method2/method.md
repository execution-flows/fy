# Method & Abstract Method

## What are Methods?
_Execution Flow (fy)_ methods are functions defined within flows that perform actions or calculations. These methods can be abstract, where they are declared but not implemented, or they can be implemented with specific behavior.

## Abstract Method Implementation
An _abstract method_ in `fy` is a method that is declared but not implemented. _Abstract methods_ are used by base flows and other method implementations to require that hosting flows provide their specific implementation. This ensures that the method is defined in any flow that inherits from the base flow or uses specific method implementation.

### Example
```py title="Abstract Method" linenums="1"
"""fy
method greet(greeting: str) -> int
"""

import abc


# fy:start <<<===
class With_Greet_MethodMixin_ABC(abc.ABC):
    @abc.abstractmethod
    def _greet(self, greeting: str) -> None:
        raise NotImplementedError()
        # fy:end <<<===
```


### Breakdown of Syntax
1. `:::py method greet(greeting: str) -> None:`
    - This line declares a new abstract method within the flow, where `greet` is the method name.
    - `:::py greeting: str` specifies the method's input parameter, which is a string.
    - `:::py -> None` specifies the return type of the method, which in this case is an `None`
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end`, including the import abc statement at the top, is automatically generated by the **_fy_** tool.
    - The generated code includes the creation of an abstract base class (ABC) mixin, `:::py With_Greet_MethodMixin_ABC`.
    - The `_greet` method is defined as an abstract method, meaning any subclass must implement this method.
3. User Input:
    - The only code the user needs to write is the method declaration within the `"""fy` block. The **_fy_** tool then generates the abstract method code.

## Method Implementation
```py linenums="1"
"""fy
method greet(greeting: str) -> None using hello_world:
"""


# fy:start <<<===
class Greet_UsingHelloWorld_MethodMixin:
    def _greet(self, greeting: str) -> None:
        # fy:end <<<===
        print("Hello World!")
```
### Breakdown of Syntax
1. `:::py method greet(greeting: str) -> None using hello_world:`
    - This line declares a new method that can be used within the flow. The method name is `:::py greet`.
    - `:::py greeting: str` specifies that the method takes a parameter named `:::py greeting` of type `:::py str` (string).
    - `:::py -> None` indicates that the method does not return any value.
    - `:::py using hello_world` indicates what we can expect from the method implementation - a usage of a constant string value "Hello, World!".
2. Code Generation:
    - Everything between `:::py # fy:start` and `:::py # fy:end` is automatically generated by the **_fy_** tool.
    - The generated code includes the class definition `:::py Greet_UsingHelloWorld_MethodMixin`.
    - The `:::py _greet` method is defined with a `:::py greeting` parameter, as specified. It is implemented by printing "Hello World!" constant string.
3. User Input:
    - The only code the user needs to write is the `:::py method` declaration within the `:::py """fy` block. After the code is generated by the **_fy_** tool, the user can add their custom implementation inside the `:::py _greet` method, such as `:::py print("Hello World!")`.

## Usage in Execution Flow
Both _abstract methods_ and _methods_ in _Execution Flows_ are designed to encapsulate behavior or actions. _Abstract methods_ enforce consistent implementation across flows, while method implementations provide a direct way to execute specific actions.
